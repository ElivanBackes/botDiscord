import discord
from discord.ext import commands
import asyncio
from discord import FFmpegPCMAudio
from pathlib import Path
import os
from dotenv import load_dotenv

print(Path("D:/Usuarios/eliva/Documents/Meus_projetos/botSetName/audios/ruliEntrance.mp3").exists())

# Carregar vari√°veis do .env
load_dotenv()

# Mapear os √°udios personalizados dos usu√°rios
user_audio_map = {}
for key, val in os.environ.items():
    if key.startswith("USER_AUDIO_"):
        path = Path(val.strip())
        user_id = int(key.split('_')[-1])
        user_audio_map[user_id] = str(path.resolve())

FFMPEG_PATH = r"D:\Usuarios\eliva\Documents\Meus_projetos\botSetName\folderDiversidade\ffmpeg\bin\ffmpeg.exe"  # Ajuste conforme seu local

TOKEN = os.getenv("DISCORD_TOKEN")
VOICE_CHANNEL_ID = int(os.getenv("VOICE_CHANNEL_ID"))

intents = discord.Intents.default()
intents.voice_states = True
intents.guilds = True
intents.members = True

bot = commands.Bot(command_prefix='!', intents=intents)


@bot.event
async def on_ready():
    print(f"ü§ñ Bot conectado como {bot.user} (ID: {bot.user.id})")
    print("üîç √Åudios configurados para usu√°rios:")
    for user_id, path in user_audio_map.items():
        print(f" - {user_id}: {path} {'‚úÖ Existe' if Path(path).exists() else '‚ùå N√ÉO encontrado'}")
    
    
    #print(f"üîç √Åudios configurados para usu√°rios:")
    #for user_id, audio_path in user_audio_map.items():
    #    print(f" - {user_id}: {audio_path} {'‚úÖ Existe' if Path(audio_path).exists() else '‚ùå N√ÉO encontrado'}")

@bot.event
async def on_voice_state_update(member, before, after):
    if member.bot:
        return

    print(f"[DEBUG] {member.name} alterou estado de voz: {before.channel} ‚Üí {after.channel}")

    if after.channel and after.channel.id == VOICE_CHANNEL_ID and before.channel != after.channel:
        print(f"üéß {member.name} entrou no canal monitorado")

        user_audio = user_audio_map.get(member.id)
        if not user_audio:
            print(f"‚ÑπÔ∏è Nenhum √°udio configurado para {member.name} (ID: {member.id})")
            return

        audio_path = Path(user_audio)
        if not audio_path.exists():
            print(f"‚ùå Arquivo de √°udio n√£o encontrado: {audio_path}")
            return

        try:
            print("üîÑ Tentando conectar ao canal de voz...")
            vc = await after.channel.connect()
            print("‚úÖ Conectado ao canal de voz com sucesso!")

            def after_playing(error):
                if error:
                    print(f"‚ùå Erro durante reprodu√ß√£o do √°udio: {error}")
                else:
                    print("‚úÖ √Åudio finalizado")

            #print(f"‚ñ∂Ô∏è Iniciando reprodu√ß√£o do √°udio: {audio_path}")
            print(f"‚ñ∂Ô∏è Iniciando reprodu√ß√£o do √°udio: {audio_path} (exists={audio_path.exists()})")
            vc.play(FFmpegPCMAudio(str(audio_path), executable=FFMPEG_PATH), after=after_playing)

            while vc.is_playing():
                await asyncio.sleep(1)

            print("üîá Desconectando do canal de voz...")
            await vc.disconnect()
            print("‚úÖ Desconectado com sucesso")

        except Exception as e:
            print(f"‚ùå Erro inesperado: {e}")

bot.run(TOKEN)
